
# 목차
- [목차](#목차)
- [reqeust가 response 되기 까지 과정](#reqeust가-response-되기-까지-과정)
- [RestController](#restcontroller)
  - [기본 구조](#기본-구조)
  - [API 공통 응답](#api-공통-응답)
  - [Controller 관련 어노테이션](#controller-관련-어노테이션)
    - [컨트롤러임을 명시](#컨트롤러임을-명시)
    - [API method 명시](#api-method-명시)
    - [request 관련 어노테이션](#request-관련-어노테이션)
  - [ControllerAdvice를 활용한 Exception Handlering](#controlleradvice를-활용한-exception-handlering)
- [Controller와 Tymeleaf](#controller와-tymeleaf)
- [filter](#filter)
- [Dispatcher Servlet](#dispatcher-servlet)
- [intercepter](#intercepter)
- [HandlerMapping, HandlerAdapter](#handlermapping-handleradapter)
- [OSIV (Open EntityManager In View)](#osiv-open-entitymanager-in-view)

# reqeust가 response 되기 까지 과정
1. filter
2. thread 할당 받아 servletRequest, servletResponse 객체 생성
3. intercepter preHandle
4. url에 맞는 controller 찾기
5. controller 실행 시작
6. (영속성 컨텍스트, 트랜잭션, JDBC 커낵션) 사용자 설정에 따라 각각에 시작, 종료 시점을 달리 할 수 있다 
7. intercepter postHandle
8. filter


# RestController
## 기본 구조
```java

@RequestMapping("/api")
@RequiredArgsConstructor
@RestController
public class SomeController{
  private final SomeService someService;

  @PostMapping
  public SomeSaveResponseDto save(@RequestBody SomeSaveRequestDto reqestDto){
    return SomeSaveResponseDto.of(someService.save(requestDto));
  }

  @GetMapping("/{id}")
  public SomeGetResponseDto find(@PathVariable("id") Long id){
    return SomeGetResponseDto.of(someService.find(id));
  }

  @PutMapping


  @DeleteMapping

}

```

## API 공통 응답
- 프론트 부분 응답 통일을 위해 구현

```java


```


## Controller 관련 어노테이션
### 컨트롤러임을 명시
- @Controller
- @ResposeBody
- @RestController

### API method 명시
- @RequestMapping
- @PostMapping
- @GetMapping
- @PutMapping
- @DeleteMapping

### request 관련 어노테이션
- @RequestBody
  - reuqest body json을 객체로 변환
- @RequestParam
  - 쿼리파라미터값을 받는 어노테이션
  - 쿼리파라미터는 웹서버 로그나 브라우저 히스토리 캐시에 저장될 가능성이 있다. 
  - 노출되지 않길 바라는 정보는 쿼리파라미터가 아닌 request body를 이용해 요청을 보내는게 안전하다.
- @PathVariable
  - url상 path variable을 받는 어노테이션
- @RequestPart
  - 파일,이미지는 request에 content-type이 multipart/form-data로 온다

## ControllerAdvice를 활용한 Exception Handlering


# Controller와 Tymeleaf
- Tymeleaf를 이용한 SSR 

```java

@RequestMapping()
@Controller
public class ViewControler(){
  public String home(){
    return "home
  }

}
```

# filter
```java
public interface FIlter{
  //filter 초기화, server 최초 실행시 실행
  public default void inint(FilterConfig filterConfig){}
  //filter 로직, request마다 실행
  public void doFilter(ServletRequest request, ServletResponse response){}
  //filter 종료, sevlet종료시 실행
  public default void destroy(){}
}

```

# Dispatcher Servlet


# intercepter
```java
public interface HandlerInterceptor{
  //Handler Adapter 호출전 실행
  default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler){}
  //Handler Adapter 호출 후 실행
  default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView){}
  //view response 이후 실행
  default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)
}
```

# HandlerMapping, HandlerAdapter
- HandlerMapping
  - url에 맞는 Handler(Controller)를 찾는 클래스
- HandlerAdapter
  - Handler를 실행할 수 있는 클래스
- 

# OSIV (Open EntityManager In View)

