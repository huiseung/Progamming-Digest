# 목차
- [목차](#목차)
- [Log](#log)
  - [Log Level](#log-level)
  - [Log 저장](#log-저장)
- [Junit MockMvc Test](#junit-mockmvc-test)
  - [Junit5](#junit5)
    - [annotation 정리](#annotation-정리)
  - [MockMVC](#mockmvc)
    - [객체 정리](#객체-정리)
  - [status 정보](#status-정보)
- [부하 테스트](#부하-테스트)
  - [JMeter](#jmeter)
    - [Test 설정](#test-설정)

# Log
- 로그에 목적은 코드가 의도한 대로 맞게 동작하는가 확인하기 위해서이다.
- 의도대로 동작하지 않은 경우 어떤 문제가 발생했는지를 남겨, 이를 보고 수정한다
  
## Log Level
- trace 세부사항
- debug 디버깅
- info 강조
- wran 경고
- error 오류
  - log.error("unexpected exception: {}, {}", e.getMessgage(), e);

## Log 저장


# Junit MockMvc Test
## Junit5
```yml
spring:
  profiles:
    active: test

---

spring:
  config:
    activate:
      on-profile: test
  application:
    name: CRUDTestApplication
  datasource:
    url: jdbc:h2:tcp://localhost/~/testdb
    username: sa
    password:
    driver-class-name: org.h2.Driver
  #
  jpa:
    show-sql: true
    database-platform: org.hibernate.dialect.H2Dialect
    properties:
      hibernate:
        format_sql: true
        ddl-auto: create
    generate-ddl: true


logging:
  level:
    root: info
    org:
      hibernate:
        type:
          descriptor:
            sql: trace

```


```java

@TestClassOrder(ClassOrderer.OrderAnnotation.class)
@TestPropertySource(properties = { "spring.config.location=classpath:application-test.yml" })
@AutoConfigureMockMvc
@SpringBootTest
public class PostControllerTest {
    @Autowired
    private MockMvc mockMvc;
    @Autowired
    private ObjectMapper objectMapper;

    private static Long postId;


    @BeforeAll
    public static void initDB(@Autowired PostService postService){
        PostSaveRequestDto requestDto = PostSaveRequestDto
        .builder()
        .title("title1")
        .price(100L)
        .category(PostCategory.BOOK_TICKET_ALBUM)
        .content("content1")
        .build();
        postId = postService.savePost(requestDto).getId();
    }

    @Order(1)
    @Nested
    @DisplayName("post save api test")
    class PostSaveTest{
        @Test
        @DisplayName("post save success test")
        public void success() throws Exception{
            PostSaveRequestDto requestDto = PostSaveRequestDto
                    .builder()
                    .title("title2")
                    .price(100L)
                    .category(PostCategory.BEAUTY)
                    .content("content2")
                    .build();
            String requestBody = objectMapper.writeValueAsString(requestDto);
            MvcResult result = mockMvc.perform(
                            MockMvcRequestBuilders.post("/api/posts")
                                    .content(requestBody)
                                    .contentType(MediaType.APPLICATION_JSON)
                                    .accept(MediaType.APPLICATION_JSON)
                    )
                    .andExpect(status().isOk())
                    .andDo(MockMvcResultHandlers.print())
                    .andReturn();
        }
    }

    @Order(2)
    @Nested
    @DisplayName("post get api test")
    class PostGetTest{
        @Test
        @DisplayName("post get success test")
        public void post_success() throws Exception{
            //when  
            MvcResult result = mockMvc.perform(
                            MockMvcRequestBuilders.get("/api/posts/1")
                                    .contentType(MediaType.APPLICATION_JSON)
                                    .accept(MediaType.APPLICATION_JSON)
                    )
                    .andExpect(status().isOk())
                    .andDo(MockMvcResultHandlers.print())
                    .andReturn();
            //then
            
        }
        @Test
        @DisplayName("posts get success test")
        public void posts_success() throws Exception{
            MvcResult result = mockMvc.perform(
                            MockMvcRequestBuilders.get("/api/posts")
                                    .contentType(MediaType.APPLICATION_JSON)
                                    .accept(MediaType.APPLICATION_JSON)
                    )
                    .andExpect(status().isOk())
                    .andDo(MockMvcResultHandlers.print())
                    .andReturn();
            JsonNode resultJson = objectMapper.readTree(result.getResponse().getContentAsString());
        }

    }

    @Order(3)
    @Nested
    @DisplayName("post update test")
    class PostUpdateTest{
        @Test
        @DisplayName("post update success test")
        public void success() throws Exception{
            PostUpdateRequestDto requestDto = PostUpdateRequestDto
                    .builder()
                    .id(postId)
                    .title("titleUpdateAfter")
                    .price(100L)
                    .category(PostCategory.BOOK_TICKET_ALBUM)
                    .content("contentUpdate")
                    .build();
            String requestBody = objectMapper.writeValueAsString(requestDto);
            MvcResult result = mockMvc.perform(
                            MockMvcRequestBuilders.put("/api/posts")
                                    .content(requestBody)
                                    .contentType(MediaType.APPLICATION_JSON)
                                    .accept(MediaType.APPLICATION_JSON)
                    )
                    .andExpect(status().isOk())
                    .andDo(MockMvcResultHandlers.print())
                    .andReturn();
            JsonNode resultJson = objectMapper.readTree(result.getResponse().getContentAsString());
        }
    }

    @Order(4)
    @Nested
    @DisplayName("delete api test")
    class PostDeleteTest{
        @Test
        @DisplayName("delete success test")
        public void success() throws Exception{
            MvcResult result = mockMvc.perform(
                            MockMvcRequestBuilders.delete("/api/posts/"+postId)
                    )
                    .andExpect(status().isOk())
                    .andDo(MockMvcResultHandlers.print())
                    .andReturn();
        }
    }
}

```


### annotation 정리
- @SpringBootTest
- @AutoCOnfigureMockMvc
- 빈 의존성 주입
  - @AutoWired private 객체 인스턴스변수
- 테스트 전, 후 작업 설정 
  - @BeforeAll: 전체 테스트 시작 전 한 번 만
  - @AfterAll: 전체 테스트 종료 후 한 번 만
  - @BeforeEach: 각 테스트 시작 전
  - @AfterEach: 각 테스트 종료 후

- @Nested
- @DisplayName
- @Test


## MockMVC
- MockMvc란 가상에 웹 객체로, API 서버 호출을 테스트 해 볼 수 있다.
### 객체 정리
- MockMvc
  - perform
  - andExpect
    - MockMvcResultMatchers 메소드를 실행시킨다
  - andDo
    - MockMvcResultHandlers에 메소드를 실행시킨다
  - andReturn
    - MvcResult를 리턴한다
- MockMvcRequestBuiders
  - get(String url)
  - post(String url)
  - delete(String url)
  - put(String url)
  - param
  - header
  - cookie
  - content
  - accept(MediaType.APPLICATION_JSON)
  - requestAttr
  - flashAttr
  - sessionAttr
- MockMutlipartHttpServletRequestBuilder
  - file()
- MockMvcResultMatchers
  - status()
  - header()
  - cookie()
  - content()
  - view()
  - forwardedUrl()
  - redirectedUrl()
  - model()
  - flash()
  - request()
- MockMvcResultHandlers
  - log
  - print   
- MvcResult

## status 정보
- 200: suceess
- 400: bad request

# 부하 테스트
## JMeter
- 다운로드
  - https://jmeter.apache.org/download_jmeter.cgi
- bin 폴더 환경 변수 등록
- 커맨드 실행: jmeter
- 메모리를 따로 사용해야 정확한 측정이 가능해 본래는 운영 서버와 측정 서버가 달라야 한다

### Test 설정
1. 테스트 생성
2. ThreadGroup 
   - action to be taken after a Sampler error
   - Number of Threads(users): 사용자 수
   - Ramp-up period(seconds): 초당 (number of threads/ramp-up period) 수 만큼 thread 증가해 ramp-up period시간이 지난 후면 number of threads 갯수에 thread가 생성된다
   - Loop Count: 테스트 반복 수행 횟수
3. ThreadGroup에 sampler/Http request 설정
  - Server Name or IP:
  - HTTP Request:
  - path:
3. Sampler에 Listener 설정
   - View Results Tree
   - Summary Report
     - samples: request 수
     - average: request 처리 시간 평균(초)
     - min:
     - max:
     - throughput: 
   - View Results in Table
4. Sampler에 Assertion 설정
   - Response Assertion
5. 