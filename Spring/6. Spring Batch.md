# 목차
- [목차](#목차)
- [스프링배치](#스프링배치)
	- [할 수 있는 것들, 왜 사용하는가](#할-수-있는-것들-왜-사용하는가)
	- [main](#main)
		- [@EnableBatchProcessing](#enablebatchprocessing)
		- [설정 클래스](#설정-클래스)
			- [SimpleBatchConfiguration](#simplebatchconfiguration)
			- [BatchConfigurerConfiguration](#batchconfigurerconfiguration)
			- [BatchAutoConfiguration](#batchautoconfiguration)
			- [사용자 정의 BatchConfiguration](#사용자-정의-batchconfiguration)
	- [프레임워크 구조](#프레임워크-구조)
		- [spring batch core](#spring-batch-core)
			- [job](#job)
				- [Job](#job-1)
				- [JobInstance](#jobinstance)
				- [JobParameters](#jobparameters)
				- [JobExecution](#jobexecution)
			- [step](#step)
			- [schema-*.sql](#schema-sql)
				- [Job 관련 테이블](#job-관련-테이블)
				- [Step 관련 테이블](#step-관련-테이블)
		- [JobRepository](#jobrepository)
			- [launch](#launch)
			- [listener](#listener)
			- [scope](#scope)
		- [spring batch infrastrucure](#spring-batch-infrastrucure)
		- [spring batch test](#spring-batch-test)
	- [Flow](#flow)
- [SpringBatch Chunk Process](#springbatch-chunk-process)
	- [Chunk Process](#chunk-process)
	- [ItemReader](#itemreader)
	- [ItemWriter](#itemwriter)
	- [ItemProcessor](#itemprocessor)
		- [CompositeItemProcessor](#compositeitemprocessor)
		- [ClassifierCompositeItemProcessor](#classifiercompositeitemprocessor)
- [SpringBatch Job Repeat, FaultTolerant, Skip, and Retry](#springbatch-job-repeat-faulttolerant-skip-and-retry)
- [SpringBatch MultiThread](#springbatch-multithread)
- [SpringBatch Listener](#springbatch-listener)
	- [JobExecutionListener](#jobexecutionlistener)
	- [StepExecutionListener](#stepexecutionlistener)
	- [ChunkListner](#chunklistner)
	- [ItemReadListener](#itemreadlistener)
	- [ItemProcessListener](#itemprocesslistener)
	- [ItemWriteListener](#itemwritelistener)
	- [SkipListener](#skiplistener)
	- [RetryListener](#retrylistener)
- [SpringBatch Test](#springbatch-test)
- [SpringBatch Operation](#springbatch-operation)
	- [JobExplorer](#jobexplorer)
	- [JobRegistry](#jobregistry)
	- [JobOperator](#joboperator)
- [SpringBatch Scheduler](#springbatch-scheduler)

# 스프링배치
## 할 수 있는 것들, 왜 사용하는가
- 배치 처리를 위한 표준 아키테처
- 배치 처리: 대용량 데이터를 배치단위로 나눠 동일 작업을 반복

## main
```java
@EnableBatchProcessing
@SpringBootApplication
public class BackApplication {

    public static void main(String[] args) {
        SpringApplication.run(BackApplication.class, args);
    }

}
```

### @EnableBatchProcessing
- 설정 클래스 4개를 실행
- 스프링배치 초기화
- 빈으로 등록된 Job 클래스를 찾아 초기화, Job 수행


```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(BatchConfigurationSelector.class)
public @interface EnableBatchProcessing {

	/**
	 * Indicate whether the configuration is going to be modularized into multiple application contexts. If true then
	 * you should not create any &#64;Bean Job definitions in this context, but rather supply them in separate (child)
	 * contexts through an {@link ApplicationContextFactory}.
	 *
	 * @return boolean indicating whether the configuration is going to be
	 * modularized into multiple application contexts.  Defaults to false.
	 */
	boolean modular() default false;

}

```

```java

public class BatchConfigurationSelector implements ImportSelector {

	@Override
	public String[] selectImports(AnnotationMetadata importingClassMetadata) {
		Class<?> annotationType = EnableBatchProcessing.class;
		AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(
				annotationType.getName(), false));
		Assert.notNull(attributes, String.format("@%s is not present on importing class '%s' as expected",
				annotationType.getSimpleName(), importingClassMetadata.getClassName()));

		String[] imports;
		if (attributes.containsKey("modular") && attributes.getBoolean("modular")) {
			imports = new String[] { ModularBatchConfiguration.class.getName() };
		}
		else {
			imports = new String[] { SimpleBatchConfiguration.class.getName() };
		}

		return imports;
	}

}

```

### 설정 클래스
#### SimpleBatchConfiguration
- JobBuilderFactory, StepBuilderFactory 빈 등록
- 스프링 배치 주요 구성 요소를 프록시 객체로 생성

```java
@Configuration(proxyBeanMethods = false)
public class SimpleBatchConfiguration extends AbstractBatchConfiguration {

	@Autowired
	private ApplicationContext context;

	private boolean initialized = false;

	private AtomicReference<JobRepository> jobRepository = new AtomicReference<>();

	private AtomicReference<JobLauncher> jobLauncher = new AtomicReference<>();

	private AtomicReference<JobRegistry> jobRegistry = new AtomicReference<>();

	private AtomicReference<PlatformTransactionManager> transactionManager = new AtomicReference<>();

	private AtomicReference<JobExplorer> jobExplorer = new AtomicReference<>();

	@Override
	@Bean
	public JobRepository jobRepository() throws Exception {
		return createLazyProxy(jobRepository, JobRepository.class);
	}

	@Override
	@Bean
	public JobLauncher jobLauncher() throws Exception {
		return createLazyProxy(jobLauncher, JobLauncher.class);
	}

	@Override
	@Bean
	public JobRegistry jobRegistry() throws Exception {
		return createLazyProxy(jobRegistry, JobRegistry.class);
	}

	@Override
	@Bean
	public JobExplorer jobExplorer() {
		return createLazyProxy(jobExplorer, JobExplorer.class);
	}

	@Override
	@Bean
	public PlatformTransactionManager transactionManager() throws Exception {
		return createLazyProxy(transactionManager, PlatformTransactionManager.class);
	}

	private <T> T createLazyProxy(AtomicReference<T> reference, Class<T> type) {
		ProxyFactory factory = new ProxyFactory();
		factory.setTargetSource(new ReferenceTargetSource<>(reference));
		factory.addAdvice(new PassthruAdvice());
		factory.setInterfaces(new Class<?>[] { type });
		@SuppressWarnings("unchecked")
		T proxy = (T) factory.getProxy();
		return proxy;
	}

	/**
	 * Sets up the basic components by extracting them from the {@link BatchConfigurer configurer}, defaulting to some
	 * sensible values as long as a unique DataSource is available.
	 *
	 * @throws Exception if there is a problem in the configurer
	 */
	protected void initialize() throws Exception {
		if (initialized) {
			return;
		}
		BatchConfigurer configurer = getConfigurer(context.getBeansOfType(BatchConfigurer.class).values());
		jobRepository.set(configurer.getJobRepository());
		jobLauncher.set(configurer.getJobLauncher());
		transactionManager.set(configurer.getTransactionManager());
		jobRegistry.set(new MapJobRegistry());
		jobExplorer.set(configurer.getJobExplorer());
		initialized = true;
	}

	private class PassthruAdvice implements MethodInterceptor {

		@Override
		public Object invoke(MethodInvocation invocation) throws Throwable {
			return invocation.proceed();
		}

	}

	private class ReferenceTargetSource<T> extends AbstractLazyCreationTargetSource {

		private AtomicReference<T> reference;

		public ReferenceTargetSource(AtomicReference<T> reference) {
			this.reference = reference;
		}

		@Override
		protected Object createObject() throws Exception {
			initialize();
			return reference.get();
		}
	}

}

```


#### BatchConfigurerConfiguration
- BasicBatchConfigurer
  - SimpleBatchConfiguration이 생성한 프록시 객체에 대응하는 실제 객체를 생성
- JPaBatchConfigurer

#### BatchAutoConfiguration
- 스프링 배치 초기화시 자동 실행
- JobLauncherApplicationRunner 빈 등록

#### 사용자 정의 BatchConfiguration
- SimpleBatchConfiguration에서 등록한 JobBuilderFactory, StepBuilderFactory 빈 활용
- job, step 정의
- JobBuilderFactory로 Step을 실행하는 Job을 정의
- StepBuilderFactory로 tasklet을 호출하는 Step을 정의

- Job: 일(작업 묶음)
- Step: 작업의 단계
- tasklet: 작업 내용


## 프레임워크 구조
- Application
- Batch Core
  - Job 실행, 모니터링 API
  - JobLauncher, Job, Step, Flow, 등
- Batch Infrastructure
  - Job 실행 흐름 처리를 위한 틀
  - Reader, Processor, Writer, Skip, Retry

- read: 데이터 조회
- process: 데이터 가공
- write: 수정 데이터 저장

### spring batch core
#### job
##### Job
- 배치 작업 클래스
- 하나 이상에 step으로 이루어져 있다
- job interface에 대해 2 종류에 구현체가 있다
  - SimpleJob: step 순차 실행
  - FlowJob: step 조건부 실행

```java
public interface Job {

	String getName();

	/**
	 * Flag to indicate if this job can be restarted, at least in principle.
	 * 
	 * @return true if this job can be restarted after a failure
	 */
	boolean isRestartable();

	/**
	 * Run the {@link JobExecution} and update the meta information like status
	 * and statistics as necessary. This method should not throw any exceptions
	 * for failed execution. Clients should be careful to inspect the
	 * {@link JobExecution} status to determine success or failure.
	 * 
	 * @param execution a {@link JobExecution}
	 */
	void execute(JobExecution execution);

	/**
	 * If clients need to generate new parameters for the next execution in a
	 * sequence they can use this incrementer. The return value may be {@code null},
	 * in the case that this job does not have a natural sequence.
	 * 
	 * @return in incrementer to be used for creating new parameters
	 */
	@Nullable
	JobParametersIncrementer getJobParametersIncrementer();

	/**
	 * A validator for the job parameters of a {@link JobExecution}. Clients of
	 * a Job may need to validate the parameters for a launch, before or during
	 * the execution.
	 * 
	 * @return a validator that can be used to check parameter values (never
	 * {@code null})
	 */
	JobParametersValidator getJobParametersValidator();

}
```

```java

public abstract class AbstractJob implements Job, StepLocator, BeanNameAware,
InitializingBean {

	protected static final Log logger = LogFactory.getLog(AbstractJob.class);

	private String name;

	private boolean restartable = true;

	private JobRepository jobRepository;

	private CompositeJobExecutionListener listener = new CompositeJobExecutionListener();

	private JobParametersIncrementer jobParametersIncrementer;

	private JobParametersValidator jobParametersValidator = new DefaultJobParametersValidator();

	private StepHandler stepHandler;

	/**
	 * Default constructor.
	 */
	public AbstractJob() {
		super();
	}

	/**
	 * Convenience constructor to immediately add name (which is mandatory but
	 * not final).
	 *
	 * @param name name of the job
	 */
	public AbstractJob(String name) {
		super();
		this.name = name;
	}

	/**
	 * A validator for job parameters. Defaults to a vanilla
	 * {@link DefaultJobParametersValidator}.
	 *
	 * @param jobParametersValidator
	 *            a validator instance
	 */
	public void setJobParametersValidator(
			JobParametersValidator jobParametersValidator) {
		this.jobParametersValidator = jobParametersValidator;
	}

	/**
	 * Assert mandatory properties: {@link JobRepository}.
	 *
	 * @see InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() throws Exception {
		Assert.notNull(jobRepository, "JobRepository must be set");
	}

	/**
	 * Set the name property if it is not already set. Because of the order of
	 * the callbacks in a Spring container the name property will be set first
	 * if it is present. Care is needed with bean definition inheritance - if a
	 * parent bean has a name, then its children need an explicit name as well,
	 * otherwise they will not be unique.
	 *
	 * @see org.springframework.beans.factory.BeanNameAware#setBeanName(java.lang.String)
	 */
	@Override
	public void setBeanName(String name) {
		if (this.name == null) {
			this.name = name;
		}
	}

	/**
	 * Set the name property. Always overrides the default value if this object
	 * is a Spring bean.
	 *
	 * @param name the name to be associated with the job.
	 *
	 * @see #setBeanName(java.lang.String)
	 */
	public void setName(String name) {
		this.name = name;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.batch.core.domain.IJob#getName()
	 */
	@Override
	public String getName() {
		return name;
	}

	/**
	 * Retrieve the step with the given name. If there is no Step with the given
	 * name, then return null.
	 *
	 * @param stepName name of the step
	 * @return the Step
	 */
	@Override
	public abstract Step getStep(String stepName);

	/**
	 * Retrieve the step names.
	 *
	 * @return the step names
	 */
	@Override
	public abstract Collection<String> getStepNames();

	@Override
	public JobParametersValidator getJobParametersValidator() {
		return jobParametersValidator;
	}

	/**
	 * Boolean flag to prevent categorically a job from restarting, even if it
	 * has failed previously.
	 *
	 * @param restartable
	 *            the value of the flag to set (default true)
	 */
	public void setRestartable(boolean restartable) {
		this.restartable = restartable;
	}

	/**
	 * @see Job#isRestartable()
	 */
	@Override
	public boolean isRestartable() {
		return restartable;
	}

	/**
	 * Public setter for the {@link JobParametersIncrementer}.
	 *
	 * @param jobParametersIncrementer
	 *            the {@link JobParametersIncrementer} to set
	 */
	public void setJobParametersIncrementer(
			JobParametersIncrementer jobParametersIncrementer) {
		this.jobParametersIncrementer = jobParametersIncrementer;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.batch.core.Job#getJobParametersIncrementer()
	 */
	@Override
	@Nullable
	public JobParametersIncrementer getJobParametersIncrementer() {
		return this.jobParametersIncrementer;
	}

	/**
	 * Public setter for injecting {@link JobExecutionListener}s. They will all
	 * be given the listener callbacks at the appropriate point in the job.
	 *
	 * @param listeners
	 *            the listeners to set.
	 */
	public void setJobExecutionListeners(JobExecutionListener[] listeners) {
		for (int i = 0; i < listeners.length; i++) {
			this.listener.register(listeners[i]);
		}
	}

	/**
	 * Register a single listener for the {@link JobExecutionListener}
	 * callbacks.
	 *
	 * @param listener
	 *            a {@link JobExecutionListener}
	 */
	public void registerJobExecutionListener(JobExecutionListener listener) {
		this.listener.register(listener);
	}

	/**
	 * Public setter for the {@link JobRepository} that is needed to manage the
	 * state of the batch meta domain (jobs, steps, executions) during the life
	 * of a job.
	 *
	 * @param jobRepository repository to use during the job execution
	 */
	public void setJobRepository(JobRepository jobRepository) {
		this.jobRepository = jobRepository;
		stepHandler = new SimpleStepHandler(jobRepository);
	}

	/**
	 * Convenience method for subclasses to access the job repository.
	 *
	 * @return the jobRepository
	 */
	protected JobRepository getJobRepository() {
		return jobRepository;
	}

	/**
	 * Extension point for subclasses allowing them to concentrate on processing
	 * logic and ignore listeners and repository calls. Implementations usually
	 * are concerned with the ordering of steps, and delegate actual step
	 * processing to {@link #handleStep(Step, JobExecution)}.
	 *
	 * @param execution
	 *            the current {@link JobExecution}
	 *
	 * @throws JobExecutionException
	 *             to signal a fatal batch framework error (not a business or
	 *             validation exception)
	 */
	abstract protected void doExecute(JobExecution execution)
			throws JobExecutionException;

	/**
	 * Run the specified job, handling all listener and repository calls, and
	 * delegating the actual processing to {@link #doExecute(JobExecution)}.
	 *
	 * @see Job#execute(JobExecution)
	 * @throws StartLimitExceededException
	 *             if start limit of one of the steps was exceeded
	 */
	@Override
	public final void execute(JobExecution execution) {

		Assert.notNull(execution, "jobExecution must not be null");

		if (logger.isDebugEnabled()) {
			logger.debug("Job execution starting: " + execution);
		}

		JobSynchronizationManager.register(execution);
		LongTaskTimer longTaskTimer = BatchMetrics.createLongTaskTimer("job.active", "Active jobs",
				Tag.of("name", execution.getJobInstance().getJobName()));
		LongTaskTimer.Sample longTaskTimerSample = longTaskTimer.start();
		Timer.Sample timerSample = BatchMetrics.createTimerSample();
		try {

			jobParametersValidator.validate(execution.getJobParameters());

			if (execution.getStatus() != BatchStatus.STOPPING) {

				execution.setStartTime(new Date());
				updateStatus(execution, BatchStatus.STARTED);

				listener.beforeJob(execution);

				try {
					doExecute(execution);
					if (logger.isDebugEnabled()) {
						logger.debug("Job execution complete: " + execution);
					}
				} catch (RepeatException e) {
					throw e.getCause();
				}
			} else {

				// The job was already stopped before we even got this far. Deal
				// with it in the same way as any other interruption.
				execution.setStatus(BatchStatus.STOPPED);
				execution.setExitStatus(ExitStatus.COMPLETED);
				if (logger.isDebugEnabled()) {
					logger.debug("Job execution was stopped: " + execution);
				}

			}

		} catch (JobInterruptedException e) {
			if (logger.isInfoEnabled()) {
				logger.info("Encountered interruption executing job: "
						+ e.getMessage());
			}
			if (logger.isDebugEnabled()) {
				logger.debug("Full exception", e);
			}
			execution.setExitStatus(getDefaultExitStatusForFailure(e, execution));
			execution.setStatus(BatchStatus.max(BatchStatus.STOPPED, e.getStatus()));
			execution.addFailureException(e);
		} catch (Throwable t) {
			logger.error("Encountered fatal error executing job", t);
			execution.setExitStatus(getDefaultExitStatusForFailure(t, execution));
			execution.setStatus(BatchStatus.FAILED);
			execution.addFailureException(t);
		} finally {
			try {
				if (execution.getStatus().isLessThanOrEqualTo(BatchStatus.STOPPED)
						&& execution.getStepExecutions().isEmpty()) {
					ExitStatus exitStatus = execution.getExitStatus();
					ExitStatus newExitStatus =
							ExitStatus.NOOP.addExitDescription("All steps already completed or no steps configured for this job.");
					execution.setExitStatus(exitStatus.and(newExitStatus));
				}

				timerSample.stop(BatchMetrics.createTimer("job", "Job duration",
						Tag.of("name", execution.getJobInstance().getJobName()),
						Tag.of("status", execution.getExitStatus().getExitCode())
				));
				longTaskTimerSample.stop();
				execution.setEndTime(new Date());

				try {
					listener.afterJob(execution);
				} catch (Exception e) {
					logger.error("Exception encountered in afterJob callback", e);
				}

				jobRepository.update(execution);
			} finally {
				JobSynchronizationManager.release();
			}

		}

	}

	/**
	 * Convenience method for subclasses to delegate the handling of a specific
	 * step in the context of the current {@link JobExecution}. Clients of this
	 * method do not need access to the {@link JobRepository}, nor do they need
	 * to worry about populating the execution context on a restart, nor
	 * detecting the interrupted state (in job or step execution).
	 *
	 * @param step
	 *            the {@link Step} to execute
	 * @param execution
	 *            the current {@link JobExecution}
	 * @return the {@link StepExecution} corresponding to this step
	 *
	 * @throws JobInterruptedException
	 *             if the {@link JobExecution} has been interrupted, and in
	 *             particular if {@link BatchStatus#ABANDONED} or
	 *             {@link BatchStatus#STOPPING} is detected
	 * @throws StartLimitExceededException
	 *             if the start limit has been exceeded for this step
	 * @throws JobRestartException
	 *             if the job is in an inconsistent state from an earlier
	 *             failure
	 */
	protected final StepExecution handleStep(Step step, JobExecution execution)
			throws JobInterruptedException, JobRestartException,
			StartLimitExceededException {
		return stepHandler.handleStep(step, execution);

	}

	/**
	 * Default mapping from throwable to {@link ExitStatus}.
	 *
	 * @param ex the cause of the failure
	 * @param execution the {@link JobExecution} instance.
	 * @return an {@link ExitStatus}
	 */
	protected ExitStatus getDefaultExitStatusForFailure(Throwable ex, JobExecution execution) {
		ExitStatus exitStatus;
		if (ex instanceof JobInterruptedException
				|| ex.getCause() instanceof JobInterruptedException) {
			exitStatus = ExitStatus.STOPPED
					.addExitDescription(JobInterruptedException.class.getName());
		} else if (ex instanceof NoSuchJobException
				|| ex.getCause() instanceof NoSuchJobException) {
			exitStatus = new ExitStatus(ExitCodeMapper.NO_SUCH_JOB, ex
					.getClass().getName());
		} else {
			exitStatus = ExitStatus.FAILED.addExitDescription(ex);
		}

		return exitStatus;
	}

	private void updateStatus(JobExecution jobExecution, BatchStatus status) {
		jobExecution.setStatus(status);
		jobRepository.update(jobExecution);
	}

	@Override
	public String toString() {
		return ClassUtils.getShortName(getClass()) + ": [name=" + name + "]";
	}

}


```


```java
public class SimpleJob extends AbstractJob {

	private List<Step> steps = new ArrayList<>();

	/**
	 * Default constructor for job with null name
	 */
	public SimpleJob() {
		this(null);
	}

	/**
	 * @param name the job name.
	 */
	public SimpleJob(String name) {
		super(name);
	}

	/**
	 * Public setter for the steps in this job. Overrides any calls to
	 * {@link #addStep(Step)}.
	 *
	 * @param steps the steps to execute
	 */
	public void setSteps(List<Step> steps) {
		this.steps.clear();
		this.steps.addAll(steps);
	}

	/**
	 * Convenience method for clients to inspect the steps for this job.
	 *
	 * @return the step names for this job
	 */
	@Override
	public Collection<String> getStepNames() {
		List<String> names = new ArrayList<>();
		for (Step step : steps) {
			names.add(step.getName());

			if(step instanceof StepLocator) {
				names.addAll(((StepLocator)step).getStepNames());
			}
		}
		return names;
	}

	/**
	 * Convenience method for adding a single step to the job.
	 *
	 * @param step a {@link Step} to add
	 */
	public void addStep(Step step) {
		this.steps.add(step);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.springframework.batch.core.job.AbstractJob#getStep(java.lang.String)
	 */
	@Override
	public Step getStep(String stepName) {
		for (Step step : this.steps) {
			if (step.getName().equals(stepName)) {
				return step;
			} else if(step instanceof StepLocator) {
				Step result = ((StepLocator)step).getStep(stepName);
				if(result != null) {
					return result;
				}
			}
		}
		return null;
	}

	/**
	 * Handler of steps sequentially as provided, checking each one for success
	 * before moving to the next. Returns the last {@link StepExecution}
	 * successfully processed if it exists, and null if none were processed.
	 *
	 * @param execution the current {@link JobExecution}
	 *
	 * @see AbstractJob#handleStep(Step, JobExecution)
	 */
	@Override
	protected void doExecute(JobExecution execution) throws JobInterruptedException, JobRestartException,
	StartLimitExceededException {

		StepExecution stepExecution = null;
		for (Step step : steps) {
			stepExecution = handleStep(step, execution);
			if (stepExecution.getStatus() != BatchStatus.COMPLETED) {
				//
				// Terminate the job if a step fails
				//
				break;
			}
		}

		//
		// Update the job status to be the same as the last step
		//
		if (stepExecution != null) {
			if (logger.isDebugEnabled()) {
				logger.debug("Upgrading JobExecution status: " + stepExecution);
			}
			execution.upgradeStatus(stepExecution.getStatus());
			execution.setExitStatus(stepExecution.getExitStatus());
		}
	}

}


```

```java
public class FlowJob extends AbstractJob {

	protected Flow flow;

	private Map<String, Step> stepMap = new ConcurrentHashMap<>();

	private volatile boolean initialized = false;

	/**
	 * Create a {@link FlowJob} with null name and no flow (invalid state).
	 */
	public FlowJob() {
		super();
	}

	/**
	 * Create a {@link FlowJob} with provided name and no flow (invalid state).
	 *
	 * @param name the name to be associated with the FlowJob.
	 */
	public FlowJob(String name) {
		super(name);
	}

	/**
	 * Public setter for the flow.
	 *
	 * @param flow the flow to set
	 */
	public void setFlow(Flow flow) {
		this.flow = flow;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Step getStep(String stepName) {
		if (!initialized) {
			init();
		}
		return stepMap.get(stepName);
	}

	/**
	 * Initialize the step names
	 */
	private void init() {
		findSteps(flow, stepMap);
	}

	/**
	 * @param flow
	 * @param map
	 */
	private void findSteps(Flow flow, Map<String, Step> map) {

		for (State state : flow.getStates()) {
			if (state instanceof StepLocator) {
				StepLocator locator = (StepLocator) state;
				for (String name : locator.getStepNames()) {
					map.put(name, locator.getStep(name));
				}
			} else if (state instanceof StepHolder) {
				Step step = ((StepHolder) state).getStep();
				String name = step.getName();
				stepMap.put(name, step);
			}
			else if (state instanceof FlowHolder) {
				for (Flow subflow : ((FlowHolder) state).getFlows()) {
					findSteps(subflow, map);
				}
			}
		}

	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Collection<String> getStepNames() {
		if (!initialized) {
			init();
		}
		return stepMap.keySet();
	}

	/**
	 * @see AbstractJob#doExecute(JobExecution)
	 */
	@Override
	protected void doExecute(final JobExecution execution) throws JobExecutionException {
		try {
			JobFlowExecutor executor = new JobFlowExecutor(getJobRepository(),
					new SimpleStepHandler(getJobRepository()), execution);
			executor.updateJobExecutionStatus(flow.start(executor).getStatus());
		}
		catch (FlowExecutionException e) {
			if (e.getCause() instanceof JobExecutionException) {
				throw (JobExecutionException) e.getCause();
			}
			throw new JobExecutionException("Flow execution ended unexpectedly", e);
		}
	}

}

```

```java
public interface Flow {

	/**
	 * @return the name of the flow
	 */
	String getName();

	/**
	 * Retrieve the State with the given name. If there is no State with the
	 * given name, then return null.
	 * 
	 * @param stateName the name of the state to retrieve
	 * @return the State
	 */
	State getState(String stateName);

	/**
	 * @param executor the {@link FlowExecutor} instance to use for the flow execution.
	 * @return a {@link FlowExecution} containing the exit status of the flow.
	 *
	 * @throws FlowExecutionException thrown if error occurs during flow execution.
	 */
	FlowExecution start(FlowExecutor executor) throws FlowExecutionException;

	/**
	 * @param stateName the name of the state to resume on.
	 * @param executor the context to be passed into each state executed.
	 * @return a {@link FlowExecution} containing the exit status of the flow.
	 *
	 * @throws FlowExecutionException thrown if error occurs during flow execution.
	 */
	FlowExecution resume(String stateName, FlowExecutor executor) throws FlowExecutionException;

	/**
	 * Convenient accessor for clients needing to explore the states of this
	 * flow.
	 * @return the states
	 */
	Collection<State> getStates();

}

```


##### JobInstance
```java
@SuppressWarnings("serial")
public class JobInstance extends Entity implements javax.batch.runtime.JobInstance{

	private final String jobName;

	public JobInstance(Long id, String jobName) {
		super(id);
		Assert.hasLength(jobName, "A jobName is required");
		this.jobName = jobName;
	}

	/**
	 * @return the job name. (Equivalent to getJob().getName())
	 */
	@Override
	public String getJobName() {
		return jobName;
	}

	@Override
	public String toString() {
		return super.toString() + ", Job=[" + jobName + "]";
	}

	@Override
	public long getInstanceId() {
		return super.getId();
	}
}

```
##### JobParameters
```java
@SuppressWarnings("serial")
public class JobParameters implements Serializable {

	private final Map<String,JobParameter> parameters;

	public JobParameters() {
		this.parameters = new LinkedHashMap<>();
	}

	public JobParameters(Map<String,JobParameter> parameters) {
		this.parameters = new LinkedHashMap<>(parameters);
	}

	/**
	 * Typesafe Getter for the Long represented by the provided key.
	 * 
	 * @param key The key to get a value for
	 * @return The <code>Long</code> value or {@code null} if the key is absent
	 */
	@Nullable
	public Long getLong(String key){
		if (!parameters.containsKey(key)) {
			return null;
		}
		Object value = parameters.get(key).getValue();
		return value==null ? null : ((Long)value).longValue();
	}

	/**
	 * Typesafe Getter for the Long represented by the provided key.  If the
	 * key does not exist, the default value will be returned.
	 * 
	 * @param key to return the value for
	 * @param defaultValue to return if the value doesn't exist
	 * @return the parameter represented by the provided key, defaultValue
	 * otherwise.
	 * @deprecated Use {@link JobParameters#getLong(java.lang.String, java.lang.Long)}
	 * instead. This method will be removed in a future release.
	 */
	@Deprecated
	public Long getLong(String key, long defaultValue){
		if(parameters.containsKey(key)){
			return getLong(key);
		}
		else{
			return defaultValue;
		}
	}

	/**
	 * Typesafe Getter for the Long represented by the provided key.  If the
	 * key does not exist, the default value will be returned.
	 *
	 * @param key to return the value for
	 * @param defaultValue to return if the value doesn't exist
	 * @return the parameter represented by the provided key, defaultValue
	 * otherwise.
	 */
	@Nullable
	public Long getLong(String key, @Nullable Long defaultValue){
		if(parameters.containsKey(key)){
			return getLong(key);
		}
		else{
			return defaultValue;
		}
	}

	/**
	 * Typesafe Getter for the String represented by the provided key.
	 * 
	 * @param key The key to get a value for
	 * @return The <code>String</code> value or {@code null} if the key is absent
	 */
	@Nullable
	public String getString(String key){
		JobParameter value = parameters.get(key);
		return value==null ? null : value.toString();
	}

	/**
	 * Typesafe Getter for the String represented by the provided key.  If the
	 * key does not exist, the default value will be returned.
	 * 
	 * @param key to return the value for
	 * @param defaultValue to return if the value doesn't exist
	 * @return the parameter represented by the provided key, defaultValue
	 * otherwise.
	 */
	@Nullable
	public String getString(String key, @Nullable String defaultValue){
		if(parameters.containsKey(key)){
			return getString(key);
		}
		else{
			return defaultValue;
		}
	}

	/**
	 * Typesafe Getter for the Long represented by the provided key.
	 * 
	 * @param key The key to get a value for
	 * @return The <code>Double</code> value or {@code null} if the key is absent
	 */
	@Nullable
	public Double getDouble(String key){
		if (!parameters.containsKey(key)) {
			return null;
		}
		Double value = (Double)parameters.get(key).getValue();
		return value==null ? null : value.doubleValue();
	}

	/**
	 * Typesafe Getter for the Double represented by the provided key.  If the
	 * key does not exist, the default value will be returned.
	 * 
	 * @param key to return the value for
	 * @param defaultValue to return if the value doesn't exist
	 * @return the parameter represented by the provided key, defaultValue
	 * otherwise.
	 * @deprecated Use {@link JobParameters#getDouble(java.lang.String, java.lang.Double)}
	 * instead. This method will be removed in a future release.
	 */
	@Deprecated
	public Double getDouble(String key, double defaultValue){
		if(parameters.containsKey(key)){
			return getDouble(key);
		}
		else{
			return defaultValue;
		}
	}

	/**
	 * Typesafe Getter for the Double represented by the provided key.  If the
	 * key does not exist, the default value will be returned.
	 *
	 * @param key to return the value for
	 * @param defaultValue to return if the value doesn't exist
	 * @return the parameter represented by the provided key, defaultValue
	 * otherwise.
	 */
	@Nullable
	public Double getDouble(String key, @Nullable Double defaultValue){
		if(parameters.containsKey(key)){
			return getDouble(key);
		}
		else{
			return defaultValue;
		}
	}

	/**
	 * Typesafe Getter for the Date represented by the provided key.
	 * 
	 * @param key The key to get a value for
	 * @return The <code>java.util.Date</code> value or {@code null} if the key
	 * is absent
	 */
	@Nullable
	public Date getDate(String key){
		return this.getDate(key,null);
	}

	/**
	 * Typesafe Getter for the Date represented by the provided key.  If the
	 * key does not exist, the default value will be returned.
	 * 
	 * @param key to return the value for
	 * @param defaultValue to return if the value doesn't exist
	 * @return the parameter represented by the provided key, defaultValue
	 * otherwise.
	 */
	@Nullable
	public Date getDate(String key, @Nullable Date defaultValue){
		if(parameters.containsKey(key)){
			return (Date)parameters.get(key).getValue();
		}
		else{
			return defaultValue;
		}
	}

	/**
	 * Get a map of all parameters, including string, long, and date.
	 * 
	 * @return an unmodifiable map containing all parameters.
	 */
	public Map<String, JobParameter> getParameters(){
		return Collections.unmodifiableMap(parameters);
	}

	/**
	 * @return true if the parameters is empty, false otherwise.
	 */
	public boolean isEmpty(){
		return parameters.isEmpty();
	}

	@Override
	public boolean equals(Object obj) {
		if(obj instanceof JobParameters == false){
			return false;
		}

		if(obj == this){
			return true;
		}

		JobParameters rhs = (JobParameters)obj;
		return this.parameters.equals(rhs.parameters);
	}

	@Override
	public int hashCode() {
		return 17 + 23 * parameters.hashCode();
	}

	@Override
	public String toString() {
		return parameters.toString();
	}

	public Properties toProperties() {
		Properties props = new Properties();

		for (Map.Entry<String, JobParameter> param : parameters.entrySet()) {
			if (param.getValue() != null) {
				props.put(param.getKey(), Objects.toString(param.getValue().toString(), ""));
			}
		}

		return props;
	}
}

```

```java
@SuppressWarnings("serial")
public class JobParameter implements Serializable {

	private final Object parameter;

	private final ParameterType parameterType;

	private final boolean identifying;

	/**
	 * Construct a new JobParameter as a String.
	 * @param parameter {@link String} instance.
	 * @param identifying true if JobParameter should be identifying.
	 */
	public JobParameter(String parameter, boolean identifying) {
		this.parameter = parameter;
		parameterType = ParameterType.STRING;
		this.identifying = identifying;
	}

	/**
	 * Construct a new JobParameter as a Long.
	 *
	 * @param parameter {@link Long} instance.
	 * @param identifying true if JobParameter should be identifying.
	 */
	public JobParameter(Long parameter, boolean identifying) {
		this.parameter = parameter;
		parameterType = ParameterType.LONG;
		this.identifying = identifying;
	}

	/**
	 * Construct a new JobParameter as a Date.
	 *
	 * @param parameter {@link Date} instance.
	 * @param identifying true if JobParameter should be identifying.
	 */
	public JobParameter(Date parameter, boolean identifying) {
		this.parameter = parameter;
		parameterType = ParameterType.DATE;
		this.identifying = identifying;
	}

	/**
	 * Construct a new JobParameter as a Double.
	 *
	 * @param parameter {@link Double} instance.
	 * @param identifying true if JobParameter should be identifying.
	 */
	public JobParameter(Double parameter, boolean identifying) {
		this.parameter = parameter;
		parameterType = ParameterType.DOUBLE;
		this.identifying = identifying;
	}


	/**
	 * Construct a new JobParameter as a String.
	 *
	 * @param parameter {@link String} instance.
	 */
	public JobParameter(String parameter) {
		this.parameter = parameter;
		parameterType = ParameterType.STRING;
		this.identifying = true;
	}

	/**
	 * Construct a new JobParameter as a Long.
	 *
	 * @param parameter {@link Long} instance.
	 */
	public JobParameter(Long parameter) {
		this.parameter = parameter;
		parameterType = ParameterType.LONG;
		this.identifying = true;
	}

	/**
	 * Construct a new JobParameter as a Date.
	 *
	 * @param parameter {@link Date} instance.
	 */
	public JobParameter(Date parameter) {
		this.parameter = parameter;
		parameterType = ParameterType.DATE;
		this.identifying = true;
	}

	/**
	 * Construct a new JobParameter as a Double.
	 *
	 * @param parameter {@link Double} instance.
	 */
	public JobParameter(Double parameter) {
		this.parameter = parameter;
		parameterType = ParameterType.DOUBLE;
		this.identifying = true;
	}

	public boolean isIdentifying() {
		return identifying;
	}

	/**
	 * @return the value contained within this JobParameter.
	 */
	public Object getValue() {

		if (parameter != null && parameter.getClass().isInstance(Date.class)) {
			return new Date(((Date) parameter).getTime());
		}
		else {
			return parameter;
		}
	}

	/**
	 * @return a ParameterType representing the type of this parameter.
	 */
	public ParameterType getType() {
		return parameterType;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj instanceof JobParameter == false) {
			return false;
		}

		if (this == obj) {
			return true;
		}

		JobParameter rhs = (JobParameter) obj;
		return parameter==null ? rhs.parameter==null && parameterType==rhs.parameterType: parameter.equals(rhs.parameter);
	}

	@Override
	public String toString() {
		return parameter == null ? null : (parameterType == ParameterType.DATE ? "" + ((Date) parameter).getTime()
				: parameter.toString());
	}

	@Override
	public int hashCode() {
		return 7 + 21 * (parameter == null ? parameterType.hashCode() : parameter.hashCode());
	}

	/**
	 * Enumeration representing the type of a JobParameter.
	 */
	public enum ParameterType {

		STRING, DATE, LONG, DOUBLE;
	}
}

```
##### JobExecution

```java
@SuppressWarnings("serial")
public class JobExecution extends Entity {

	private final JobParameters jobParameters;

	private JobInstance jobInstance;

	private volatile Collection<StepExecution> stepExecutions = Collections.synchronizedSet(new LinkedHashSet<>());

	private volatile BatchStatus status = BatchStatus.STARTING;

	private volatile Date startTime = null;

	private volatile Date createTime = new Date(System.currentTimeMillis());

	private volatile Date endTime = null;

	private volatile Date lastUpdated = null;

	private volatile ExitStatus exitStatus = ExitStatus.UNKNOWN;

	private volatile ExecutionContext executionContext = new ExecutionContext();

	private transient volatile List<Throwable> failureExceptions = new CopyOnWriteArrayList<>();

	private final String jobConfigurationName;

	public JobExecution(JobExecution original) {
		this.jobParameters = original.getJobParameters();
		this.jobInstance = original.getJobInstance();
		this.stepExecutions = original.getStepExecutions();
		this.status = original.getStatus();
		this.startTime = original.getStartTime();
		this.createTime = original.getCreateTime();
		this.endTime = original.getEndTime();
		this.lastUpdated = original.getLastUpdated();
		this.exitStatus = original.getExitStatus();
		this.executionContext = original.getExecutionContext();
		this.failureExceptions = original.getFailureExceptions();
		this.jobConfigurationName = original.getJobConfigurationName();
		this.setId(original.getId());
		this.setVersion(original.getVersion());
	}

	/**
	 * Because a JobExecution isn't valid unless the job is set, this
	 * constructor is the only valid one from a modeling point of view.
	 *
	 * @param job the job of which this execution is a part
	 * @param id {@link Long} that represents the id for the JobExecution.
	 * @param jobParameters {@link JobParameters} instance for this JobExecution.
	 * @param jobConfigurationName {@link String} instance that represents the
	 * job configuration name (used with JSR-352).
	 */
	public JobExecution(JobInstance job, Long id, @Nullable JobParameters jobParameters, String jobConfigurationName) {
		super(id);
		this.jobInstance = job;
		this.jobParameters = jobParameters == null ? new JobParameters() : jobParameters;
		this.jobConfigurationName = jobConfigurationName;
	}

	public JobExecution(JobInstance job, JobParameters jobParameters, String jobConfigurationName) {
		this(job, null, jobParameters, jobConfigurationName);
	}

	public JobExecution(Long id, JobParameters jobParameters, String jobConfigurationName) {
		this(null, id, jobParameters, jobConfigurationName);
	}

	/**
	 * Constructor for transient (unsaved) instances.
	 *
	 * @param job the enclosing {@link JobInstance}
	 * @param jobParameters {@link JobParameters} instance for this JobExecution.
	 */
	public JobExecution(JobInstance job, JobParameters jobParameters) {
		this(job, null, jobParameters, null);
	}

	public JobExecution(Long id, JobParameters jobParameters) {
		this(null, id, jobParameters, null);
	}

	public JobExecution(Long id) {
		this(null, id, null, null);
	}

	public JobParameters getJobParameters() {
		return this.jobParameters;
	}

	public Date getEndTime() {
		return endTime;
	}

	public void setJobInstance(JobInstance jobInstance) {
		this.jobInstance = jobInstance;
	}

	public void setEndTime(Date endTime) {
		this.endTime = endTime;
	}

	public Date getStartTime() {
		return startTime;
	}

	public void setStartTime(Date startTime) {
		this.startTime = startTime;
	}

	public BatchStatus getStatus() {
		return status;
	}

	/**
	 * Set the value of the status field.
	 *
	 * @param status the status to set
	 */
	public void setStatus(BatchStatus status) {
		this.status = status;
	}

	/**
	 * Upgrade the status field if the provided value is greater than the
	 * existing one. Clients using this method to set the status can be sure
	 * that they don't overwrite a failed status with an successful one.
	 *
	 * @param status the new status value
	 */
	public void upgradeStatus(BatchStatus status) {
		this.status = this.status.upgradeTo(status);
	}

	/**
	 * Convenience getter for for the id of the enclosing job. Useful for DAO
	 * implementations.
	 *
	 * @return the id of the enclosing job
	 */
	public Long getJobId() {
		if (jobInstance != null) {
			return jobInstance.getId();
		}
		return null;
	}

	/**
	 * @param exitStatus {@link ExitStatus} instance to be used for job execution.
	 */
	public void setExitStatus(ExitStatus exitStatus) {
		this.exitStatus = exitStatus;
	}

	/**
	 * @return the exitCode
	 */
	public ExitStatus getExitStatus() {
		return exitStatus;
	}

	/**
	 * @return the Job that is executing.
	 */
	public JobInstance getJobInstance() {
		return jobInstance;
	}

	/**
	 * Accessor for the step executions.
	 *
	 * @return the step executions that were registered
	 */
	public Collection<StepExecution> getStepExecutions() {
		return Collections.unmodifiableList(new ArrayList<>(stepExecutions));
	}

	/**
	 * Register a step execution with the current job execution.
	 * @param stepName the name of the step the new execution is associated with
	 * @return {@link StepExecution} an empty {@code StepExecution} associated with this
	 * 	{@code JobExecution}.
	 */
	public StepExecution createStepExecution(String stepName) {
		StepExecution stepExecution = new StepExecution(stepName, this);
		this.stepExecutions.add(stepExecution);
		return stepExecution;
	}

	/**
	 * Test if this {@link JobExecution} indicates that it is running. It should
	 * be noted that this does not necessarily mean that it has been persisted
	 * as such yet.
	 *
	 * @return true if the end time is null and the start time is not null
	 */
	public boolean isRunning() {
		return startTime != null && endTime == null;
	}

	/**
	 * Test if this {@link JobExecution} indicates that it has been signalled to
	 * stop.
	 * @return true if the status is {@link BatchStatus#STOPPING}
	 */
	public boolean isStopping() {
		return status == BatchStatus.STOPPING;
	}

	/**
	 * Signal the {@link JobExecution} to stop. Iterates through the associated
	 * {@link StepExecution}s, calling {@link StepExecution#setTerminateOnly()}.
	 *
	 * @deprecated Use {@link org.springframework.batch.core.launch.JobOperator#stop(long)}
	 * or {@link org.springframework.batch.core.launch.support.CommandLineJobRunner}
	 * with the "-stop" option instead.
	 */
	@Deprecated
	public void stop() {
		for (StepExecution stepExecution : stepExecutions) {
			stepExecution.setTerminateOnly();
		}
		status = BatchStatus.STOPPING;
	}

	/**
	 * Sets the {@link ExecutionContext} for this execution
	 *
	 * @param executionContext the context
	 */
	public void setExecutionContext(ExecutionContext executionContext) {
		this.executionContext = executionContext;
	}

	/**
	 * Returns the {@link ExecutionContext} for this execution. The content is
	 * expected to be persisted after each step completion (successful or not).
	 *
	 * @return the context
	 */
	public ExecutionContext getExecutionContext() {
		return executionContext;
	}

	/**
	 * @return the time when this execution was created.
	 */
	public Date getCreateTime() {
		return createTime;
	}

	/**
	 * @param createTime creation time of this execution.
	 */
	public void setCreateTime(Date createTime) {
		this.createTime = createTime;
	}

	public String getJobConfigurationName() {
		return this.jobConfigurationName;
	}

	/**
	 * Package private method for re-constituting the step executions from
	 * existing instances.
	 * @param stepExecution execution to be added
	 */
	void addStepExecution(StepExecution stepExecution) {
		stepExecutions.add(stepExecution);
	}

	/**
	 * Get the date representing the last time this JobExecution was updated in
	 * the JobRepository.
	 *
	 * @return Date representing the last time this JobExecution was updated.
	 */
	public Date getLastUpdated() {
		return lastUpdated;
	}

	/**
	 * Set the last time this JobExecution was updated.
	 *
	 * @param lastUpdated {@link Date} instance to mark job execution's lastUpdated attribute.
	 */
	public void setLastUpdated(Date lastUpdated) {
		this.lastUpdated = lastUpdated;
	}

	public List<Throwable> getFailureExceptions() {
		return failureExceptions;
	}

	/**
	 * Add the provided throwable to the failure exception list.
	 *
	 * @param t {@link Throwable} instance to be added failure exception list.
	 */
	public synchronized void addFailureException(Throwable t) {
		this.failureExceptions.add(t);
	}

	/**
	 * Return all failure causing exceptions for this JobExecution, including
	 * step executions.
	 *
	 * @return List&lt;Throwable&gt; containing all exceptions causing failure for
	 * this JobExecution.
	 */
	public synchronized List<Throwable> getAllFailureExceptions() {

		Set<Throwable> allExceptions = new HashSet<>(failureExceptions);
		for (StepExecution stepExecution : stepExecutions) {
			allExceptions.addAll(stepExecution.getFailureExceptions());
		}

		return new ArrayList<>(allExceptions);
	}

	/**
	 * Deserialize and ensure transient fields are re-instantiated when read
	 * back.
	 *
	 * @param stream instance of {@link ObjectInputStream}.
	 *
	 * @throws IOException thrown if error occurs during read.
	 * @throws ClassNotFoundException thrown if class is not found.
	 */
	private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
		stream.defaultReadObject();
		failureExceptions = new ArrayList<>();
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.springframework.batch.core.domain.Entity#toString()
	 */
	@Override
	public String toString() {
		return super.toString()
				+ String.format(", startTime=%s, endTime=%s, lastUpdated=%s, status=%s, exitStatus=%s, job=[%s], jobParameters=[%s]",
						startTime, endTime, lastUpdated, status, exitStatus, jobInstance, jobParameters);
	}

	/**
	 * Add some step executions.  For internal use only.
	 * @param stepExecutions step executions to add to the current list
	 */
	public void addStepExecutions(List<StepExecution> stepExecutions) {
		if (stepExecutions!=null) {
			this.stepExecutions.removeAll(stepExecutions);
			this.stepExecutions.addAll(stepExecutions);
		}
	}
}

```
```java
@SuppressWarnings("serial")
public class JobExecutionException extends Exception {

	/**
	 * Construct a {@link JobExecutionException} with a generic message.
	 * @param msg the message
	 */
	public JobExecutionException(String msg) {
		super(msg);
	}

	/**
	 * Construct a {@link JobExecutionException} with a generic message and a
	 * cause.
	 * 
	 * @param msg the message
	 * @param cause the cause of the exception
	 */
	public JobExecutionException(String msg, Throwable cause) {
		super(msg, cause);
	}
}

```

```java
public interface JobExecutionListener {

	/**
	 * Callback before a job executes.
	 *
	 * @param jobExecution the current {@link JobExecution}
	 */
	void beforeJob(JobExecution jobExecution);

	/**
	 * Callback after completion of a job. Called after both both successful and
	 * failed executions. To perform logic on a particular status, use
	 * "if (jobExecution.getStatus() == BatchStatus.X)".
	 *
	 * @param jobExecution the current {@link JobExecution}
	 */
	void afterJob(JobExecution jobExecution);

}


```


#### step
#### schema-*.sql
- 자동 생성 스키마 코드
##### Job 관련 테이블
- BATCH_JOB_INSTANCE: Job 실행시 (job_name, job_key)로 tuple 저장
- BATCH_JOB_EXECUTION: Job 실행 정보. 생성, 시작, 종료시간, 실행상태, 메세지
- BATCH_JOB_EXECUTION_PARAMS: Job parameter 정보
- BATCH_JOB_EXECUTION_CONTEXT: step간 공유 가능한 데이터를 Jso 형태로 저장
- BATCH_JOB_SEQ
- BATCH_JOB_EXECUTION_SEQ

##### Step 관련 테이블
- BATCH_STEP_EXECUTION: step 실행 정보.
- BATCH_STEP_EXECUTION_CONTEXT: step별 데이터를 json형태로 저장
- BATCH_STEP_EXECUTION_SEQ

### JobRepository

#### launch
```java

public interface JobLauncher {

	/**
	 * Start a job execution for the given {@link Job} and {@link JobParameters}
	 * . If a {@link JobExecution} was able to be created successfully, it will
	 * always be returned by this method, regardless of whether or not the
	 * execution was successful. If there is a past {@link JobExecution} which
	 * has paused, the same {@link JobExecution} is returned instead of a new
	 * one created. A exception will only be thrown if there is a failure to
	 * start the job. If the job encounters some error while processing, the
	 * JobExecution will be returned, and the status will need to be inspected.
	 *
	 * @param job the job to be executed.
	 * @param jobParameters the parameters passed to this execution of the job.
	 * @return the {@link JobExecution} if it returns synchronously. If the
	 * implementation is asynchronous, the status might well be unknown.
	 * 
	 * @throws JobExecutionAlreadyRunningException if the JobInstance identified
	 * by the properties already has an execution running.
	 * @throws IllegalArgumentException if the job or jobInstanceProperties are
	 * null.
	 * @throws JobRestartException if the job has been run before and
	 * circumstances that preclude a re-start.
	 * @throws JobInstanceAlreadyCompleteException if the job has been run
	 * before with the same parameters and completed successfully
	 * @throws JobParametersInvalidException if the parameters are not valid for
	 * this job
	 */
	public JobExecution run(Job job, JobParameters jobParameters) throws JobExecutionAlreadyRunningException,
			JobRestartException, JobInstanceAlreadyCompleteException, JobParametersInvalidException;

}

```


#### listener
#### scope

### spring batch infrastrucure


### spring batch test

------

## Flow

------

# SpringBatch Chunk Process
## Chunk Process
## ItemReader
## ItemWriter
## ItemProcessor
### CompositeItemProcessor
### ClassifierCompositeItemProcessor

# SpringBatch Job Repeat, FaultTolerant, Skip, and Retry

# SpringBatch MultiThread

# SpringBatch Listener
## JobExecutionListener
## StepExecutionListener
## ChunkListner
## ItemReadListener
## ItemProcessListener
## ItemWriteListener
## SkipListener
## RetryListener

# SpringBatch Test

# SpringBatch Operation
## JobExplorer
## JobRegistry
## JobOperator

# SpringBatch Scheduler